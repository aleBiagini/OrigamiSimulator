<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alessandro e Simona</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Alex+Brush&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/choices.js@10.2.0/public/assets/styles/choices.min.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: radial-gradient(ellipse at center, #3a4a4f 0%, #1a2a2f 50%, #0a1a1f 100%);
            min-height: 100vh;
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, #3a4a4f 0%, #1a2a2f 50%, #0a1a1f 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 1;
            transition: opacity 0.8s ease-out;
        }

        #loading-screen.fade-out {
            opacity: 0;
            pointer-events: none;
        }

        #loading-screen img {
            width: 600px;
            height: 600px;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; }
        }

        .nav-container {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.8s ease-out;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .nav-container.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .nav-btn {
            padding: 12px 28px;
            font-family: 'Alex Brush', cursive;
            font-size: 24px;
            color: #1c1c1c;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(139, 115, 85, 0.4);
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .nav-btn:hover {
            background: rgba(255, 255, 255, 1);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
        }

        .nav-submenu {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
            opacity: 0;
            max-height: 0;
            overflow: hidden;
            pointer-events: none;
            transition: opacity 0.3s ease, max-height 0.4s ease;
        }

        .nav-submenu.expanded {
            opacity: 1;
            max-height: 300px;
            pointer-events: auto;
        }

        .nav-submenu .nav-btn {
            font-size: 20px;
            padding: 10px 24px;
        }

        @media (max-width: 768px) {
            .nav-container {
                bottom: 20px;
            }

            .nav-btn {
                font-size: 20px;
                padding: 10px 24px;
            }

            .nav-submenu .nav-btn {
                font-size: 18px;
            }
        }

        .audio-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 44px;
            height: 44px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(139, 115, 85, 0.4);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .audio-toggle.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .audio-toggle:hover {
            background: rgba(255, 255, 255, 1);
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
        }

        .audio-toggle svg {
            width: 22px;
            height: 22px;
            fill: #1c1c1c;
        }

        /* RSVP Form Overlay */
        .rsvp-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .rsvp-overlay.visible {
            display: flex;
        }

        .rsvp-form-container {
            background: linear-gradient(135deg, #fefefe 0%, #f5f0e8 100%);
            border-radius: 20px;
            padding: 40px;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(139, 115, 85, 0.3);
        }

        .rsvp-close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 36px;
            height: 36px;
            background: rgba(139, 115, 85, 0.1);
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 24px;
            color: #8b7355;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .rsvp-close-btn:hover {
            background: rgba(139, 115, 85, 0.2);
            transform: scale(1.1);
        }

        .rsvp-title {
            font-family: 'Alex Brush', cursive;
            font-size: 42px;
            color: #1c1c1c;
            text-align: center;
            margin-bottom: 30px;
        }

        .rsvp-form-group {
            margin-bottom: 20px;
        }

        .rsvp-label {
            display: block;
            font-family: 'Segoe UI', sans-serif;
            font-size: 14px;
            color: #555;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .rsvp-select,
        .rsvp-input {
            width: 100%;
            padding: 14px 16px;
            font-family: 'Segoe UI', sans-serif;
            font-size: 16px;
            border: 1px solid rgba(139, 115, 85, 0.3);
            border-radius: 10px;
            background: white;
            color: #1c1c1c;
            transition: all 0.3s ease;
        }

        .rsvp-select:focus,
        .rsvp-input:focus {
            outline: none;
            border-color: #8b7355;
            box-shadow: 0 0 0 3px rgba(139, 115, 85, 0.1);
        }

        .choices {
            margin-bottom: 0;
        }

        .choices__inner {
            width: 100%;
            padding: 10px 16px;
            font-family: 'Segoe UI', sans-serif;
            font-size: 16px;
            border: 1px solid rgba(139, 115, 85, 0.3);
            border-radius: 10px;
            background: white;
            color: #1c1c1c;
            min-height: auto;
        }

        .choices__list--single {
            padding: 4px 16px 4px 4px;
        }

        .choices__input {
            font-size: 16px;
            background: white;
            color: #1c1c1c;
        }

        .choices[data-type*="select-one"] .choices__input {
            display: block;
            width: 100%;
            padding: 10px 16px;
            border-bottom: 1px solid rgba(139, 115, 85, 0.3);
            background: #f9f9f9;
            margin: 0;
        }

        .choices[data-type*="select-one"] .choices__inner {
            padding-bottom: 10px;
        }

        .choices[data-type*="select-one"]::after {
            border-color: #8b7355 transparent transparent transparent;
        }

        .choices.is-open .choices__inner,
        .choices.is-focused .choices__inner {
            border-color: #8b7355;
            box-shadow: 0 0 0 3px rgba(139, 115, 85, 0.1);
        }

        .choices__list--dropdown {
            border: 1px solid rgba(139, 115, 85, 0.3);
            border-radius: 10px;
            z-index: 100;
            background: white;
        }

        .choices__list--dropdown .choices__item--selectable.is-highlighted {
            background-color: rgba(139, 115, 85, 0.15);
        }

        .choices__list--dropdown .choices__item {
            padding: 12px 16px;
            color: #1c1c1c;
        }

        .choices__list--single .choices__item {
            color: #1c1c1c;
        }

        .choices__placeholder {
            color: #666;
        }

        .rsvp-submit-btn {
            width: 100%;
            padding: 16px;
            font-family: 'Alex Brush', cursive;
            font-size: 28px;
            color: white;
            background: linear-gradient(135deg, #8b7355 0%, #6b5a47 100%);
            border: none;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(139, 115, 85, 0.3);
        }

        .rsvp-submit-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(139, 115, 85, 0.4);
        }

        .rsvp-submit-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .rsvp-message {
            text-align: center;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: none;
        }

        .rsvp-message.success {
            display: block;
            background: rgba(76, 175, 80, 0.1);
            color: #2e7d32;
            border: 1px solid rgba(76, 175, 80, 0.3);
        }

        .rsvp-message.error {
            display: block;
            background: rgba(244, 67, 54, 0.1);
            color: #c62828;
            border: 1px solid rgba(244, 67, 54, 0.3);
        }

        .rsvp-loading {
            display: none;
            text-align: center;
            padding: 40px;
        }

        .rsvp-loading p {
            color: #5a4a3a;
            font-weight: 500;
        }

        .rsvp-loading.visible {
            display: block;
        }

        .rsvp-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(139, 115, 85, 0.2);
            border-top-color: #8b7355;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .dietary-notes-field {
            display: none;
        }

        .dietary-notes-field.visible {
            display: block;
            margin-top: 10px;
        }

        .choices[data-type*="select-multiple"] .choices__inner {
            min-height: 50px;
        }

        .choices[data-type*="select-multiple"] .choices__item {
            background: rgba(139, 115, 85, 0.15);
            border: 1px solid rgba(139, 115, 85, 0.3);
            border-radius: 6px;
            color: #1c1c1c;
        }

        .choices[data-type*="select-multiple"] .choices__button {
            border-left: 1px solid rgba(139, 115, 85, 0.4);
        }

        .rsvp-radio-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .rsvp-radio-option {
            display: flex;
            align-items: center;
            cursor: pointer;
            padding: 12px 16px;
            border: 1px solid rgba(139, 115, 85, 0.3);
            border-radius: 10px;
            transition: all 0.3s ease;
        }

        .rsvp-radio-option:hover {
            border-color: #8b7355;
            background: rgba(139, 115, 85, 0.05);
        }

        .rsvp-radio-option input[type="radio"] {
            margin-right: 12px;
            width: 18px;
            height: 18px;
            accent-color: #8b7355;
        }

        .rsvp-radio-option input[type="radio"]:checked + .rsvp-radio-label {
            font-weight: 600;
            color: #8b7355;
        }

        .rsvp-radio-label {
            font-size: 15px;
            color: #333;
        }

        #attending-fields {
            transition: opacity 0.3s ease, max-height 0.3s ease;
        }

        #attending-fields.hidden {
            opacity: 0.4;
            pointer-events: none;
        }

        @media (max-width: 768px) {
            .rsvp-form-container {
                padding: 25px;
            }

            .rsvp-title {
                font-size: 32px;
            }
        }

    </style>
</head>
<body>
    <div id="loading-screen">
        <img src="/assets/wisteria.svg" alt="Loading" onerror="this.style.display='none'">
    </div>
    <div id="container"></div>

    <div class="nav-container">
        <div class="nav-submenu" id="nav-submenu">
            <button class="nav-btn" onclick="showHome()">Home</button>
            <button class="nav-btn" onclick="showDoveQuando()">Dove e Quando</button>
            <button class="nav-btn" onclick="openRsvpForm()">Conferma Partecipazione</button>
            <button class="nav-btn" onclick="showListaNozze()">Lista Nozze</button>
        </div>
        <button class="nav-btn" id="nav-toggle" onclick="document.getElementById('nav-submenu').classList.toggle('expanded')">Maggiori Informazioni</button>
    </div>

    <div id="youtube-audio-player"></div>

    <button class="audio-toggle" id="audio-toggle" onclick="toggleAudio()">
        <svg id="audio-icon-on" viewBox="0 0 24 24">
            <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
        </svg>
        <svg id="audio-icon-off" style="display: none;" viewBox="0 0 24 24">
            <path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/>
        </svg>
    </button>

    <!-- RSVP Form Overlay -->
    <div class="rsvp-overlay" id="rsvp-overlay">
        <div class="rsvp-form-container">
            <button class="rsvp-close-btn" onclick="closeRsvpForm()">&times;</button>
            
            <h2 class="rsvp-title">Conferma Partecipazione</h2>
            
            <div id="rsvp-message" class="rsvp-message"></div>
            
            <div id="rsvp-loading" class="rsvp-loading">
                <div class="rsvp-spinner"></div>
                <p>Invio in corso...</p>
            </div>
            
            <form id="rsvp-form">
                <div class="rsvp-form-group">
                    <label class="rsvp-label" for="guest-select">Seleziona i partecipanti</label>
                    <select class="rsvp-select" id="guest-select" multiple required>
                    </select>
                </div>
                
                <div class="rsvp-form-group">
                    <label class="rsvp-label">Parteciperai al matrimonio?</label>
                    <div class="rsvp-radio-group">
                        <label class="rsvp-radio-option">
                            <input type="radio" name="attending" value="yes" checked onchange="toggleAttendingFields()">
                            <span class="rsvp-radio-label">Si, parteciperò</span>
                        </label>
                        <label class="rsvp-radio-option">
                            <input type="radio" name="attending" value="no" onchange="toggleAttendingFields()">
                            <span class="rsvp-radio-label">No, non potrò partecipare</span>
                        </label>
                    </div>
                </div>
                
                <div id="attending-fields">
                    <div class="rsvp-form-group">
                        <label class="rsvp-label" for="dietary-select">Preferenze alimentari</label>
                        <select class="rsvp-select" id="dietary-select" onchange="toggleDietaryNotes()">
                            <option value="nessuna">Nessuna preferenza</option>
                            <option value="vegetariano">Vegetariano</option>
                            <option value="vegano">Vegano</option>
                            <option value="allergie">Intolleranze / Allergie</option>
                        </select>
                        <div id="dietary-notes-container" class="dietary-notes-field">
                            <input type="text" class="rsvp-input" id="dietary-notes" placeholder="Specifica le tue intolleranze o allergie">
                        </div>
                    </div>
                    
                </div>
                
                <button type="submit" class="rsvp-submit-btn" id="rsvp-submit-btn">Conferma</button>
            </form>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/choices.js@10.2.0/public/assets/scripts/choices.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/environments/RoomEnvironment.js"></script>
    <script src="exports/TriFoldPaper.js"></script>

    <script>
        // =========================================
        // RSVP FORM LOGIC
        // =========================================

        let guestsData = [];
        let guestSelectChoices = null;

        async function loadGuests() {
            const select = document.getElementById('guest-select');
            
            if (guestSelectChoices) {
                guestSelectChoices.destroy();
                guestSelectChoices = null;
            }
            
            try {
                const response = await fetch('/api/guests');
                const data = await response.json();
                
                if (data.guests && data.guests.length > 0) {
                    guestsData = data.guests;
                    select.innerHTML = '';
                    data.guests.forEach(guest => {
                        const option = document.createElement('option');
                        option.value = guest.id;
                        option.textContent = guest.registration ? guest.name + ' (gia registrato)' : guest.name;
                        select.appendChild(option);
                    });
                } else {
                    select.innerHTML = '';
                }
            } catch (error) {
                console.error('Error loading guests:', error);
                select.innerHTML = '';
            }
            
            guestSelectChoices = new Choices(select, {
                searchEnabled: true,
                searchPlaceholderValue: 'Cerca...',
                itemSelectText: '',
                noResultsText: 'Nessun risultato',
                noChoicesText: 'Nessuna scelta disponibile',
                shouldSort: false,
                position: 'bottom',
                removeItemButton: true,
                placeholderValue: 'Seleziona uno o piu partecipanti...',
                maxItemCount: -1
            });
        }

        function openRsvpForm() {
            document.getElementById('nav-submenu').classList.remove('expanded');
            document.getElementById('rsvp-overlay').classList.add('visible');
            document.getElementById('rsvp-form').reset();
            document.getElementById('rsvp-message').className = 'rsvp-message';
            document.getElementById('rsvp-message').textContent = '';
            document.getElementById('dietary-notes-container').classList.remove('visible');
            document.getElementById('attending-fields').classList.remove('hidden');
            loadGuests();
        }

        function closeRsvpForm() {
            document.getElementById('rsvp-overlay').classList.remove('visible');
        }

        function toggleDietaryNotes() {
            const select = document.getElementById('dietary-select');
            const container = document.getElementById('dietary-notes-container');
            if (select.value === 'allergie') {
                container.classList.add('visible');
            } else {
                container.classList.remove('visible');
            }
        }

        function toggleAttendingFields() {
            const attending = document.querySelector('input[name="attending"]:checked').value === 'yes';
            const fieldsContainer = document.getElementById('attending-fields');
            
            if (attending) {
                fieldsContainer.classList.remove('hidden');
            } else {
                fieldsContainer.classList.add('hidden');
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            const form = document.getElementById('rsvp-form');
            
            form.addEventListener('submit', async function(e) {
                e.preventDefault();
                
                const submitBtn = document.getElementById('rsvp-submit-btn');
                const loading = document.getElementById('rsvp-loading');
                const message = document.getElementById('rsvp-message');
                
                const selectedValues = guestSelectChoices.getValue(true);
                const guestIds = Array.isArray(selectedValues) ? selectedValues.map(id => parseInt(id)) : [];
                const attending = document.querySelector('input[name="attending"]:checked').value === 'yes';
                const dietaryPreference = document.getElementById('dietary-select').value;
                const dietaryNotes = document.getElementById('dietary-notes').value;
                
                if (guestIds.length === 0) {
                    message.textContent = 'Per favore seleziona almeno un partecipante';
                    message.className = 'rsvp-message error';
                    return;
                }
                
                submitBtn.disabled = true;
                form.style.display = 'none';
                loading.classList.add('visible');
                message.className = 'rsvp-message';
                
                try {
                    const response = await fetch('/api/register', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            guestIds: guestIds,
                            attending,
                            dietaryPreference: attending ? dietaryPreference : 'nessuna',
                            dietaryNotes: attending && dietaryPreference === 'allergie' ? dietaryNotes : null
                        })
                    });
                    
                    const result = await response.json();
                    
                    loading.classList.remove('visible');
                    
                    if (response.ok) {
                        message.textContent = attending 
                            ? 'Grazie per la conferma! Ti aspettiamo il 1 Giugno 2026.'
                            : 'Risposta registrata. Ci dispiace che non potrai essere presente.';
                        message.className = 'rsvp-message success';
                        setTimeout(() => {
                            closeRsvpForm();
                        }, 3000);
                    } else {
                        form.style.display = 'block';
                        message.textContent = result.error || 'Errore durante la registrazione';
                        message.className = 'rsvp-message error';
                        submitBtn.disabled = false;
                    }
                } catch (error) {
                    console.error('Registration error:', error);
                    loading.classList.remove('visible');
                    form.style.display = 'block';
                    message.textContent = 'Errore di connessione. Riprova.';
                    message.className = 'rsvp-message error';
                    submitBtn.disabled = false;
                }
            });
        });

        // Close overlay when clicking outside the form
        document.getElementById('rsvp-overlay').addEventListener('click', function(e) {
            if (e.target === this) {
                closeRsvpForm();
            }
        });

        // =========================================
        // SPARKLE EFFECT HELPERS & CLASS
        // =========================================

        function createSparkleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.2, 'rgba(255, 255, 220, 0.8)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.1)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);

            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        class SparkleSystem {
            constructor(targetGroup, boundsWidth, boundsHeight) {
                this.particleCount = 15;
                this.active = true;
                this.bounds = { w: boundsWidth, h: boundsHeight };
                
                this.geometry = new THREE.BufferGeometry();
                this.positions = new Float32Array(this.particleCount * 3);
                this.sizes = new Float32Array(this.particleCount);
                this.userData = []; 

                for (let i = 0; i < this.particleCount; i++) {
                    this.resetParticle(i);
                    this.userData[i].phase = Math.random() * Math.PI * 2;
                }

                this.geometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));
                this.geometry.setAttribute('pSize', new THREE.BufferAttribute(this.sizes, 1));

                this.material = new THREE.PointsMaterial({
                    size: 0.05, 
                    map: createSparkleTexture(),
                    transparent: true,
                    opacity: 0.9,
                    blending: THREE.AdditiveBlending, 
                    depthWrite: false, 
                    vertexColors: false
                });
                 
                this.material.onBeforeCompile = (shader) => {
                    shader.vertexShader = 'attribute float pSize;\n' + shader.vertexShader;
                    shader.vertexShader = shader.vertexShader.replace(
                        'gl_PointSize = size;',
                        'gl_PointSize = size * pSize;'
                    );
                };

                this.points = new THREE.Points(this.geometry, this.material);
                this.points.position.z = 0.01; 
                targetGroup.add(this.points);
            }

            resetParticle(index) {
                const i3 = index * 3;
                this.positions[i3] = (Math.random() - 0.5) * this.bounds.w * 0.9;
                this.positions[i3 + 1] = (Math.random() - 0.5) * this.bounds.h * 0.9;
                this.positions[i3 + 2] = (Math.random() * 0.02); 

                this.userData[index] = {
                    phase: 0, 
                    speed: 0.02 + Math.random() * 0.04, 
                    maxSize: 0.8 + Math.random() * 0.7 
                };
                this.sizes[index] = 0;
            }

            update() {
                if (!this.active) return;
                const sizesAttr = this.geometry.attributes.pSize;
                let needsUpdate = false;

                for (let i = 0; i < this.particleCount; i++) {
                    const data = this.userData[i];
                    data.phase += data.speed;
                    let normalizedSine = (Math.sin(data.phase - Math.PI/2) + 1) / 2;
                    this.sizes[i] = normalizedSine * data.maxSize;
                    
                    if (data.phase > Math.PI * 2.5) {
                         this.resetParticle(i);
                    }
                    needsUpdate = true;
                }

                if (needsUpdate) {
                    sizesAttr.needsUpdate = true;
                    this.geometry.attributes.position.needsUpdate = true;
                }
            }

            stop() {
                if (!this.active) return;
                this.active = false;
                const fadeOut = setInterval(() => {
                    this.material.opacity -= 0.05;
                    if (this.material.opacity <= 0) {
                        clearInterval(fadeOut);
                        this.points.visible = false;
                    }
                }, 16);
            }
        }

        // =========================================
        // YOUTUBE MUSIC INTEGRATION
        // =========================================

        var player;
        var isMusicPlaying = false;

        // 1. Load the IFrame Player API code asynchronously.
        var tag = document.createElement('script');
        tag.src = "https://www.youtube.com/iframe_api";
        var firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

        // 2. This function creates an <iframe> (and YouTube player)
        //    after the API code downloads.
        function onYouTubeIframeAPIReady() {
            player = new YT.Player('youtube-audio-player', {
                height: '1',
                width: '1',
                videoId: 'Jk4P10nsq4c',
                playerVars: {
                    'autoplay': 0, 
                    'controls': 0,
                    'loop': 1,
                    'playlist': 'Jk4P10nsq4c',
                    'origin': window.location.origin
                },
                events: {
                    'onReady': onPlayerReady,
                    'onError': onPlayerError,
                    'onStateChange': onPlayerStateChange
                }
            });
        }

        // 3. The API will call this function when the video player is ready.
        function onPlayerReady(event) {
            console.log('YouTube player ready');
            event.target.setVolume(30);
        }

        function onPlayerError(event) {
            console.error('YouTube player error:', event.data);
            // Error codes: 2=invalid ID, 5=HTML5 error, 100=not found, 101/150=embedding disabled
        }

        function onPlayerStateChange(event) {
            console.log('YouTube player state:', event.data);
        }

        function startMusic() {
            console.log('startMusic called, player:', player, 'isMusicPlaying:', isMusicPlaying);
            if (player && typeof player.playVideo === 'function' && !isMusicPlaying) {
                player.playVideo();
                isMusicPlaying = true;
                updateAudioIcon();
                console.log('playVideo called');
            }
        }

        var isMuted = false;

        function toggleAudio() {
            if (!player || typeof player.isMuted !== 'function') return;
            
            if (player.isMuted()) {
                player.unMute();
                isMuted = false;
            } else {
                player.mute();
                isMuted = true;
            }
            updateAudioIcon();
        }

        function updateAudioIcon() {
            var iconOn = document.getElementById('audio-icon-on');
            var iconOff = document.getElementById('audio-icon-off');
            if (isMuted) {
                iconOn.style.display = 'none';
                iconOff.style.display = 'block';
            } else {
                iconOn.style.display = 'block';
                iconOff.style.display = 'none';
            }
        }

        // =========================================
        // MAIN SCENE SETUP
        // =========================================

        const container = document.getElementById('container');
        const scene = new THREE.Scene();
        
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        
        const sceneHeight = 6;
        const fov = 45 * (Math.PI / 180);
        const targetFill = 0.7;
        const cameraZ = (sceneHeight / 2) / Math.tan(fov / 2) / targetFill;
        camera.position.set(0, 0, cameraZ);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(0x000000, 0);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.9;
        container.appendChild(renderer.domElement);

        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        pmremGenerator.compileEquirectangularShader();
        scene.environment = pmremGenerator.fromScene(new THREE.RoomEnvironment()).texture;

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.15);
        scene.add(ambientLight);
        
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.10);
        hemiLight.position.set(100, 500, 200);
        scene.add(hemiLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.1);
        directionalLight.position.set(-1, 1, cameraZ);
        directionalLight.target.position.set(-1.5, -1, -1);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);
        scene.add(directionalLight.target);
        
        const backLight = new THREE.DirectionalLight(0xffffff, 0.15);
        backLight.position.set(-5, -5, -5);
        scene.add(backLight);

        // =========================================
        // TEXTURE & TEXT GENERATION
        // =========================================
        
        const textureLoader = new THREE.TextureLoader();

     // Function to write text onto the paper texture dynamically
function createWrittenPaperTexture(baseImage, wisteriaImage) {
    const canvas = document.createElement('canvas');
    const size = 2048; 
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');

    // 1. Draw the base paper texture
    if (baseImage) {
        const half = size / 2;
        ctx.drawImage(baseImage, 0, 0, half, half);
        ctx.drawImage(baseImage, half, 0, half, half);
        ctx.drawImage(baseImage, 0, half, half, half);
        ctx.drawImage(baseImage, half, half, half, half);
    } else {
        ctx.fillStyle = '#f5f5f5';
        ctx.fillRect(0, 0, size, size);
    }

    // 2. Configure Text Styles globals
    const centerX = size / 2;
    const centerY = size / 2;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = '#1c1c1c'; 

    // Helper function to wrap text
    function wrapText(text, maxWidth, font) {
        ctx.font = font;
        const words = text.split(' ');
        const lines = [];
        let currentLine = '';
        
        for (const word of words) {
            const testLine = currentLine ? currentLine + ' ' + word : word;
            const metrics = ctx.measureText(testLine);
            if (metrics.width > maxWidth && currentLine) {
                lines.push(currentLine);
                currentLine = word;
            } else {
                currentLine = testLine;
            }
        }
        if (currentLine) lines.push(currentLine);
        return lines;
    }

    // 3. Draw wisteria image at the top
    let yPos = 300; // Margine superiore
    
    if (wisteriaImage) {
        const targetWidth = 1200; 
        const targetHeight = 600; 

        ctx.save();
        ctx.globalCompositeOperation = 'multiply'; 
        ctx.filter = 'contrast(1.5) saturate(2)'; 
        ctx.drawImage(wisteriaImage, centerX - targetWidth / 2, yPos, targetWidth, targetHeight);
        ctx.restore(); 

        yPos += targetHeight + 0; 
    } else {
        yPos = centerY - 350;
    }

    // 4. Draw The Body Text
    const maxWidth = size * 0.80; 
    const lineHeight = 105;
    const fontBody = '500 120px "Alex Brush", cursive'; 

    const para1 = "Con grande gioia vi invitiamo a condividere questo giorno speciale con noi. Sarà un onore celebrare il nostro amore circondati dalle persone che più amiamo.";
    
    const lines1 = wrapText(para1, maxWidth, fontBody);
    
    ctx.font = fontBody; 
    ctx.fillStyle = '#1c1c1c'; 
    
    for (const line of lines1) {
        ctx.fillText(line, centerX, yPos);
        yPos += lineHeight;
    }

    yPos += 60; 

    // Signature
    ctx.font = '600 100px "Alex Brush", cursive';
    ctx.fillText("Con affetto,", centerX, yPos);
    
    yPos += 90; 
    
    ctx.font = '700 120px "Alex Brush", cursive'; // Big Signature
    ctx.fillText("Simona e Alessandro", centerX, yPos);
   

    // ============================================================

    // 6. Create Texture
    const tex = new THREE.CanvasTexture(canvas);
    tex.encoding = THREE.sRGBEncoding;
    tex.flipY = true;
    
    tex.minFilter = THREE.LinearFilter;
    tex.magFilter = THREE.LinearFilter;
    tex.anisotropy = renderer.capabilities.getMaxAnisotropy(); 

    return tex;
}

// Function to create texture with "Dove e Quando" content
function createDoveQuandoTexture(baseImage, wisteriaImage) {
    const canvas = document.createElement('canvas');
    const size = 2048; 
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');

    // 1. Draw the base paper texture
    if (baseImage) {
        const half = size / 2;
        ctx.drawImage(baseImage, 0, 0, half, half);
        ctx.drawImage(baseImage, half, 0, half, half);
        ctx.drawImage(baseImage, 0, half, half, half);
        ctx.drawImage(baseImage, half, half, half, half);
    } else {
        ctx.fillStyle = '#f5f5f5';
        ctx.fillRect(0, 0, size, size);
    }

    // 2. Configure Text Styles
    const centerX = size / 2;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = '#1c1c1c'; 

    // 3. Draw wisteria image at the top
    let yPos = 300;
    
    if (wisteriaImage) {
        const targetWidth = 1200; 
        const targetHeight = 600; 

        ctx.save();
        ctx.globalCompositeOperation = 'multiply'; 
        ctx.filter = 'contrast(1.5) saturate(2)'; 
        ctx.drawImage(wisteriaImage, centerX - targetWidth / 2, yPos, targetWidth, targetHeight);
        ctx.restore(); 

        yPos += targetHeight + 80; 
    } else {
        yPos = 400;
    }

    // 4. Draw the event details
    ctx.font = '700 180px "Alex Brush", cursive';
    ctx.fillText("01 Giugno 2026", centerX, yPos);
    
    yPos += 200;
    
    ctx.font = '500 120px "Alex Brush", cursive';
    ctx.fillText("I Borghi dell'Eremo", centerX, yPos);
    
    yPos += 130;
    
    ctx.font = '400 100px "Alex Brush", cursive';
    ctx.fillText("Piegaro - vocabolo Crocicchia", centerX, yPos);
    
    yPos += 180;
    
    ctx.font = '600 140px "Alex Brush", cursive';
    ctx.fillText("ore 17.30", centerX, yPos);

    // 5. Create Texture
    const tex = new THREE.CanvasTexture(canvas);
    tex.encoding = THREE.sRGBEncoding;
    tex.flipY = true;
    tex.minFilter = THREE.LinearFilter;
    tex.magFilter = THREE.LinearFilter;
    tex.anisotropy = renderer.capabilities.getMaxAnisotropy(); 

    return tex;
}

// Function to show "Dove e Quando" content
function showDoveQuando() {
    // Close submenu
    document.getElementById('nav-submenu').classList.remove('expanded');
    
    // Generate new texture and update paper
    if (paperColorImage) {
        writtenTexture = createDoveQuandoTexture(paperColorImage, wisteriaImage);
        updatePaperMaterial();
    }
}

// Function to create texture with "Lista Nozze" content
function createListaNozzeTexture(baseImage, wisteriaImage) {
    const canvas = document.createElement('canvas');
    const size = 2048; 
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');

    // 1. Draw the base paper texture
    if (baseImage) {
        const half = size / 2;
        ctx.drawImage(baseImage, 0, 0, half, half);
        ctx.drawImage(baseImage, half, 0, half, half);
        ctx.drawImage(baseImage, 0, half, half, half);
        ctx.drawImage(baseImage, half, half, half, half);
    } else {
        ctx.fillStyle = '#f5f5f5';
        ctx.fillRect(0, 0, size, size);
    }

    // 2. Configure Text Styles
    const centerX = size / 2;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = '#1c1c1c'; 

    // 3. Draw wisteria image at the top
    let yPos = 250;
    
    if (wisteriaImage) {
        const targetWidth = 1000; 
        const targetHeight = 500; 

        ctx.save();
        ctx.globalCompositeOperation = 'multiply'; 
        ctx.filter = 'contrast(1.5) saturate(2)'; 
        ctx.drawImage(wisteriaImage, centerX - targetWidth / 2, yPos, targetWidth, targetHeight);
        ctx.restore(); 

        yPos += targetHeight + 60; 
    } else {
        yPos = 350;
    }

    // 4. Draw the bank details
    ctx.font = '600 120px "Alex Brush", cursive';
    ctx.fillText("Coordinate Bancarie", centerX, yPos);
    
    yPos += 140;
    
    ctx.font = '400 65px "Inter", sans-serif';
    ctx.fillText("IT56 F036 6901 6009 0080 8901 241", centerX, yPos);
    
    yPos += 110;
    
    ctx.font = '600 70px "Alex Brush", cursive';
    ctx.fillText("Intestato a", centerX, yPos);
    
    yPos += 90;
    
    ctx.font = '600 90px "Alex Brush", cursive';
    ctx.fillText("Alessandro Biagini & Simona Fiorucci", centerX, yPos);
    
    yPos += 125;
    
    ctx.font = '600 100px "Alex Brush", cursive';
    ctx.fillText("Con gratitudine", centerX, yPos);

    // 5. Create Texture
    const tex = new THREE.CanvasTexture(canvas);
    tex.encoding = THREE.sRGBEncoding;
    tex.flipY = true;
    tex.minFilter = THREE.LinearFilter;
    tex.magFilter = THREE.LinearFilter;
    tex.anisotropy = renderer.capabilities.getMaxAnisotropy(); 

    return tex;
}

// Function to show "Lista Nozze" content
function showListaNozze() {
    // Close submenu
    document.getElementById('nav-submenu').classList.remove('expanded');
    
    // Generate new texture and update paper
    if (paperColorImage) {
        writtenTexture = createListaNozzeTexture(paperColorImage, wisteriaImage);
        updatePaperMaterial();
    }
}

// Function to show Home (first message)
function showHome() {
    // Close submenu
    document.getElementById('nav-submenu').classList.remove('expanded');
    
    // Generate original texture and update paper
    if (paperColorImage) {
        writtenTexture = createWrittenPaperTexture(paperColorImage, wisteriaImage);
        updatePaperMaterial();
    }
}

    // Load wisteria SVG for the invitation
        let wisteriaImage = null;
        let paperColorImage = null;
        const wisteriaImg = new Image();
        wisteriaImg.onload = function() {
            wisteriaImage = wisteriaImg;
            // Regenerate texture if paper already exists
            if (paper && paperColorImage) {
                writtenTexture = createWrittenPaperTexture(paperColorImage, wisteriaImage);
                updatePaperMaterial();
            }
        };
        wisteriaImg.src = '/assets/wisteria.svg';

        // Load Base Textures
        const paperNormal = textureLoader.load('/assets/paper/Paper005_1K-JPG_NormalGL.jpg');
        paperNormal.repeat.set(2, 2);
        paperNormal.wrapS = THREE.RepeatWrapping;
        paperNormal.wrapT = THREE.RepeatWrapping;

        const paperRoughness = textureLoader.load('/assets/paper/Paper005_1K-JPG_Roughness.jpg');
        paperRoughness.repeat.set(2, 2);
        paperRoughness.wrapS = THREE.RepeatWrapping;
        paperRoughness.wrapT = THREE.RepeatWrapping;

        // Load Color, then generate text texture
        let writtenTexture = null;
        let plainPaperTexture = null;
        textureLoader.load('/assets/paper/Paper005_1K-JPG_Color.jpg', (imageTexture) => {
            paperColorImage = imageTexture.image;
            writtenTexture = createWrittenPaperTexture(paperColorImage, wisteriaImage);
            // Create plain paper texture (no text) for side panels using canvas
            const canvas = document.createElement('canvas');
            const size = 1024;
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            // Tile the paper texture 2x2
            const half = size / 2;
            ctx.drawImage(imageTexture.image, 0, 0, half, half);
            ctx.drawImage(imageTexture.image, half, 0, half, half);
            ctx.drawImage(imageTexture.image, 0, half, half, half);
            ctx.drawImage(imageTexture.image, half, half, half, half);
            plainPaperTexture = new THREE.CanvasTexture(canvas);
            plainPaperTexture.encoding = THREE.sRGBEncoding;
            plainPaperTexture.wrapS = THREE.ClampToEdgeWrapping;
            plainPaperTexture.wrapT = THREE.ClampToEdgeWrapping;
            // Once created, we will apply it to the paper in the object setup below
            if(paper) updatePaperMaterial(); 
        });

        // =========================================
        // OBJECTS
        // =========================================

        const paperWidth = 0.9;
        const paperHeight = 0.85;
        const paper = new TriFoldPaper({
            width: paperWidth,
            height: paperHeight,
            foldDuration: 800,
            frontColor: 0xffffff, 
            backColor: 0xffffff
        });

        function updatePaperMaterial() {
            if(!writtenTexture || !plainPaperTexture) return;

            // Helper to apply material to a mesh
            function applyMaterial(mesh, texture) {
                let mat = mesh.material;
                if (Array.isArray(mat)) mat = mat[0];

                if (mat.type !== 'MeshStandardMaterial') {
                    const newMat = new THREE.MeshStandardMaterial({
                        color: 0xffffff,
                        side: THREE.DoubleSide
                    });
                    mesh.material = newMat;
                    mat = newMat;
                }

                mat.map = texture;
                mat.normalMap = paperNormal;
                mat.normalScale.set(1.5, 1.5);
                mat.roughnessMap = paperRoughness;
                mat.roughness = 1.0; 
                mat.needsUpdate = true;
            }

            // Apply text texture ONLY to center panel
            applyMaterial(paper.centerPanel, writtenTexture);
            applyMaterial(paper.centerPanelBack, writtenTexture);

            // Apply plain paper texture to side panels
            applyMaterial(paper.leftPanel, plainPaperTexture);
            applyMaterial(paper.leftPanelBack, plainPaperTexture);
            applyMaterial(paper.rightPanel, plainPaperTexture);
            applyMaterial(paper.rightPanelBack, plainPaperTexture);
        }

        // Try to update immediately if texture cached, otherwise callback handles it
        updatePaperMaterial();

        const sparkleSystem = new SparkleSystem(paper.group, paperWidth, paperHeight);

        // Desk Setup Group
        const deskSetup = new THREE.Group();
        
        const initialRotationX = -55 * (Math.PI / 180);
        const initialRotationZ = -25 * (Math.PI / 180);
        const initialDeskY = -1;

        deskSetup.rotation.x = initialRotationX;
        deskSetup.rotation.z = initialRotationZ;
        deskSetup.position.y = initialDeskY;

        const paperOffsetX = 0.8;
        const paperOffsetY = -0.5;
        const paperOffsetZ = 2.7;

        paper.group.position.set(paperOffsetX, paperOffsetY, paperOffsetZ);
        deskSetup.add(paper.group);
        
        const loader = new THREE.GLTFLoader();
        loader.load('/assets/desk.glb', (gltf) => {
            const desk = gltf.scene;
            desk.scale.set(3, 3, 3);
            desk.rotation.x = Math.PI / 2;
            desk.position.z = -0.01;
            
            desk.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                    if (child.material) child.material.envMapIntensity = 1.5;
                }
            });
            deskSetup.add(desk);
            
            const loadingScreen = document.getElementById('loading-screen');
            loadingScreen.classList.add('fade-out');
            setTimeout(() => { loadingScreen.style.display = 'none'; }, 800);
        }, undefined, (e) => {
             console.warn("Desk missing");
             document.getElementById('loading-screen').classList.add('fade-out');
        });
        
        const groundGeometry = new THREE.PlaneGeometry(50, 50);
        const groundMaterial = new THREE.ShadowMaterial({ opacity: 0.5 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.position.z = -0.02;
        ground.receiveShadow = true;
        deskSetup.add(ground);
        
        scene.add(deskSetup);

        paper.setSeal('/assets/wisteria-seal.svg', 0.15);
        paper.setFoldProgress(1); 

        // =========================================
        // ANIMATION LOGIC
        // =========================================

        let animationState = 'idle'; 
        let animStartTime = 0;
        const ANIM_DURATION = 1500;
        let autoOpenTimeout = null; 

        function easeInOutCubic(x) {
            return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2;
        }

        function openLetter() {
            if (autoOpenTimeout) {
                clearTimeout(autoOpenTimeout);
                autoOpenTimeout = null;
            }
            animationState = 'open';
            paper.unfold();
            setTimeout(() => {
                document.querySelector('.nav-container').classList.add('visible');
                document.getElementById('audio-toggle').classList.add('visible');
            }, 800);
        }

        function startZoomSequence() {
            if (animationState !== 'idle') return;
            
            animationState = 'zooming';
            animStartTime = performance.now();
            sparkleSystem.stop(); 
        }

        function updateAnimation() {
            if (animationState !== 'zooming') return;

            const now = performance.now();
            const elapsed = now - animStartTime;
            const progress = Math.min(elapsed / ANIM_DURATION, 1);
            const ease = easeInOutCubic(progress);

            const currentCameraZ = initialCameraZ + (3.5 - initialCameraZ) * ease;
            camera.position.z = currentCameraZ;

            deskSetup.rotation.x = initialRotationX + (0 - initialRotationX) * ease;
            deskSetup.rotation.z = initialRotationZ + (0 - initialRotationZ) * ease;

            const targetGroupX = -paperOffsetX; 
            const targetGroupY = -paperOffsetY; 

            deskSetup.position.x = 0 + (targetGroupX - 0) * ease;
            deskSetup.position.y = initialDeskY + (targetGroupY - initialDeskY) * ease;

            if (progress >= 1) {
                animationState = 'waiting_to_open';
                // Auto-open after 3 seconds if user doesn't click
                autoOpenTimeout = setTimeout(() => {
                    if (animationState === 'waiting_to_open') {
                        openLetter();
                    }
                }, 3000);
            }
        }

        const initialCameraZ = cameraZ;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Auto-start zoom after 3 seconds if user hasn't clicked
        let autoStartTimeout = setTimeout(() => {
            if (animationState === 'idle') {
                startZoomSequence();
            }
        }, 3000);

        window.addEventListener('click', (event) => {
            // Attempt to start music on any click
            // This ensures browser autoplay policies are satisfied
            startMusic();

            if (animationState === 'idle') {
                clearTimeout(autoStartTimeout);
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);

                const intersects = raycaster.intersectObjects(paper.group.children, true);
                
                if (intersects.length > 0) {
                    startZoomSequence();
                }
            } else if (animationState === 'waiting_to_open') {
                openLetter();
            } else if (animationState === 'open') {
                paper.handleClick(raycaster); 
            }
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function animate() {
            requestAnimationFrame(animate);
            sparkleSystem.update();
            updateAnimation();
            renderer.render(scene, camera);
        }

        // Add this at the end of your script to fix "Flash of Unstyled Text"
        document.fonts.ready.then(function () {
            // This runs once all fonts (Alex Brush) are fully loaded
            if (paper && paperColorImage) {
                // Re-run the texture generation with the correct font
                writtenTexture = createWrittenPaperTexture(paperColorImage, wisteriaImage);
                updatePaperMaterial();
            }
        });

        animate();
    </script>
</body>
</html>